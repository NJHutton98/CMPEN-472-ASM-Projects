***********************************************************************
*
* Title:          Rapid Data Transmission with HCS12 and ADC
*
* Objective:      CMPEN 472 Homework 11
*
* Revision:       V1.0  for CodeWarrior 5.2 Debugger Simulation
*
* Date:	          Apr.23, 2021
*
* Programmer:     Nicholas Hutton
*
* Company:        The Pennsylvania State University
*                 Department of Computer Science and Engineering
*
* Program:        Interrupt-based program that 
*                 
*
* Algorithm:      Simple Serial I/O use, typewriter, Timer Module
*                 
*
* Register use:	  A, B, X, Y, CCR
*
* Memory use:     RAM Locations from $3000 for data, 
*                 RAM Locations from $3100 for program
*
*	Input:			    Parameters hard-coded in the program - PORTB, 
*                 Terminal connected over serial
* Output:         
*                 Terminal connected over serial
*                 PORTB bit 7 to bit 4, 7-segment MSB
*                 PORTB bit 3 to bit 0, 7-segment LSB
*
* Observation:    User input-driven program that gathers numbers generated by interrupts
*                 and prints them over serial
*
***********************************************************************
* Parameter Declearation Section
*
* Export Symbols
            XDEF        Entry        ; export 'Entry' symbol
            ABSENTRY    Entry        ; for assembly entry point

; include derivative specific macros
PORTB       EQU         $0001
DDRB        EQU         $0003

SCIBDH      EQU         $00C8        ; Serial port (SCI) Baud Register H
SCIBDL      EQU         $00C9        ; Serial port (SCI) Baud Register L
SCICR2      EQU         $00CB        ; Serial port (SCI) Control Register 2
SCISR1      EQU         $00CC        ; Serial port (SCI) Status Register 1
SCIDRL      EQU         $00CF        ; Serial port (SCI) Data Register

TIOS        EQU         $0040        ; Timer Input Capture (IC) or Output Compare (OC) select
TIE         EQU         $004C        ; Timer interrupt enable register
TCNTH       EQU         $0044        ; Timer free runing main counter
TSCR1       EQU         $0046        ; Timer system control 1
TSCR2       EQU         $004D        ; Timer system control 2
TFLG1       EQU         $004E        ; Timer interrupt flag 1
TC2H        EQU         $0054        ; Timer channel 2 register

ATDCTL2     EQU  $0082            ; Analog-to-Digital Converter (ADC) registers
ATDCTL3     EQU  $0083
ATDCTL4     EQU  $0084
ATDCTL5     EQU  $0085
ATDSTAT0    EQU  $0086
ATDDR0H     EQU  $0090
ATDDR0L     EQU  $0091
ATDDR7H     EQU  $009e
ATDDR7L     EQU  $009f


CR          equ         $0d          ; carriage return, ASCII 'Return' key
LF          equ         $0a          ; line feed, ASCII 'next line' character

intct       equ         79           ; my PC simulation works,  79 => 1 sec approximately
;intct       equ         7999         ; For 1 sec., interrupt count is 8000
; 125usec * 8000 = 1 sec,  0 to 7999 count is 8000
; For simulation, reduce this number for faster 1 sec. timing
; If interrupt count less than 8000, then not 1 sec yet.
;    no need to update display.


;*******************************************************
; variable/data section
            ORG    $3000             ; RAMStart defined as $3000
                                     ; in MC9S12C128 chip

ATDdone     DS.B  1               ; ADC finish indicator, 1 = ATD finished

ctr125u     DS.W    1                ; 16bit interrupt counter for 125 uSec. of time
cbufct      DS.B    1                ; user input character buffer fill count
cbuf        DS.B    6                ; user input character buffer, maximum 6 char
cerror      DS.B    1                ; user input error count, 1 - 9 (ASCII $31 - $39)

iYes        DS.B    1
s125us       DS.B    2                ; stored value for 125us
DecBuff     DS.B        $0005        ; used to store Hex -> Decimal -> ASCII conversion, terminated with NULL
HCount      DS.B        $0001        ; number of ASCII characters to be converted to hex

;*******************************************************
; interrupt vector section
;            ORG     $3FEA            ; Timer channel 2 interrupt vector setup, HC12 board
            ORG     $FFEA            ; Timer channel 2 interrupt vector setup, simulator
            DC.W    oc2isr

;*******************************************************
; code section

            ORG    $3100
Entry
            LDS    #Entry         ; initialize the stack pointer

            ldd    #$0001       ; Set SCI Baud Register = $0001 => 2M baud at 24MHz (for simulation)
;            ldd    #$0002       ; Set SCI Baud Register = $0002 => 1M baud at 24MHz
;            ldd    #$000D       ; Set SCI Baud Register = $000D => 115200 baud at 24MHz
;            ldd    #$009C       ; Set SCI Baud Register = $009C => 9600 baud at 24MHz
            std    SCIBDH       ; SCI port baud rate change

            ldaa   #$0C         ; Enable SCI port Tx and Rx units
            staa   SCICR2       ; disable SCI interrupts

            LDAA   #%11111111   ; Set PORTB bit 0,1,2,3,4,5,6,7
            STAA   DDRB         ; as output
            STAA   PORTB        ; set all bits of PORTB, initialize

; ATD initialization
            LDAA  #%11000000       ; Turn ON ADC, clear flags, Disable ATD interrupt
            STAA  ATDCTL2
            LDAA  #%00001000       ; Single conversion per sequence, no FIFO
            STAA  ATDCTL3
            LDAA  #%10000111       ; 8bit, ADCLK=24MHz/16=1.5MHz, sampling time=2*(1/ADCLK)
            STAA  ATDCTL4          ; for SIMULATION

            ldx     #$0400       ; store 1024 constant so we can compare how many numbers have been printed
            ;ldx     #$B
            stx     s125us
            
            ldx     #msg1            ; print the first message, 'Hello'
            jsr     printmsg
            jsr     nextline
            ldx     #msg2            ; print the second message, user instruction
            jsr     printmsg
            jsr     nextline


main1       
            jsr		getchar
			      cmpa	#0
			      beq		main1
			      jsr		putchar			;typewriter

            cmpa  #CR       ; check for Enter pressed  
            bne   main1     ; if not, continue typewriter
            ldx   #msg3     ; print '> Be sure to start saving Terminal data'
            jsr   printmsg

main2       ldx		#msg4			;print '> Press the switch SW0'
      			jsr		printmsg
      			jsr		nextline
      			jsr		nextline

      			LDAA	#%00000000		; Clear PORTB
      			STAA	PORTB			  
			
swWait		  LDAA	PORTB			    ; Wait for user to flip SW0			
      			ANDA	#%00000001
      			tsta
      			
      			BEQ		swWait			  ; SW0 was not flipped

      			jsr		StartTimer2oc


      			ldx		#0				  ; clear the number counter variable
      			stx		ctr125u


numLoop
      			ldx		ctr125u
      			cpx		s125us		; check if 1024 numbers have been collected
      			bge		done	

      			
adcwait     ldaa  ATDSTAT0         ; Wait until ATD conversion finish
            anda  #%10000000       ; check SCF bit, wait for ATD conversion to finish
            beq   adcwait
      			
            ;ldaa  iYes      ;compare iYes with 0, if it equals 0, then branch (loop) 
      			;tsta
      			;beq   numLoop  ;this is the sleep loop while we wait for the interrupt routine to happen

      			;clr   iYes      ; clear the interrupt flag again
      			      			
      			clra
      			ldab  ATDDR0L          ; for SIMULATOR, pick up the lower 8bit result       
      			jsr		hex2asciiDec			; and convert it
      			ldx   #DecBuff   ; print the number
            jsr   printmsg
            jsr   nextline

      			ldx		ctr125u
      			inx						   ; increment the count of numbers we've collected
      			stx		ctr125u
      			bra		numLoop		
      			
done
      			sei					     ; stop the interrupt, OC2
      			jsr		nextline
      			jsr		nextline
      			ldx		#msg5		   ;print '>done! close output file.'
      			jsr		printmsg
      			jsr		nextline
      			ldx		#msg6		   ;print '>ready for next data transmission"
      			jsr		printmsg
      			jsr		nextline
      			BRA		main2

;*******************************************************
;subroutine section below

;***********Timer OC2 interrupt service routine***************
oc2isr
            ldd   #3000              ; 125usec with (24MHz/1 clock)
            addd  TC2H               ;    for next interrupt
            std   TC2H               ; 
            LDAA  #%10000111       ; right justified, unsigned, single conversion,
            STAA  ATDCTL5          ; single channel, CHANNEL 7, start the conversion
            bset  TFLG1,%00000100    ; clear timer CH2 interrupt flag, not needed if fast clear enabled
            ;bset  iYes,%11111111     ; every time the OC2 occur, set iYes flag 
            
oc2done     RTI
;***********end of Timer OC2 interrupt service routine********


;***************StartTimer2oc************************
;* Program: Start the timer interrupt, timer channel 2 output compare
;* Input:   Constants - channel 2 output compare, 125usec at 24MHz
;* Output:  None, only the timer interrupt
;* Registers modified: D used and CCR modified
;* Algorithm:
;             initialize TIOS, TIE, TSCR1, TSCR2, TC2H, and TFLG1
;**********************************************
StartTimer2oc
            PSHD
            LDAA   #%00000100
            STAA   TIOS              ; set CH2 Output Compare
            STAA   TIE               ; set CH2 interrupt Enable
            LDAA   #%10000000        ; enable timer, Fast Flag Clear not set
            STAA   TSCR1
            LDAA   #%00000000        ; TOI Off, TCRE Off, TCLK = BCLK/1
            STAA   TSCR2             ;   not needed if started from reset

            LDD     #3000            ; 125usec with (24MHz/1 clock)
            ADDD    TCNTH            ;    for first interrupt
            STD     TC2H             ; 

            PULD
            BSET   TFLG1,%00000100   ; initial Timer CH2 interrupt flag Clear, not needed if fast clear set
            CLI                      ; enable interrupt
            RTS
;***************end of StartTimer2oc*****************


;***********printmsg***************************
;* Program: Output character string to SCI port, print message
;* Input:   Register X points to ASCII characters in memory
;* Output:  message printed on the terminal connected to SCI port
;* 
;* Registers modified: CCR
;* Algorithm:
;     Pick up 1 byte from memory where X register is pointing
;     Send it out to SCI port
;     Update X register to point to the next byte
;     Repeat until the byte data $00 is encountered
;       (String is terminated with NULL=$00)
;**********************************************
NULL            equ     $00
printmsg        psha                   ;Save registers
                pshx
printmsgloop    ldaa    1,X+           ;pick up an ASCII character from string
                                       ;   pointed by X register
                                       ;then update the X register to point to
                                       ;   the next byte
                cmpa    #NULL
                beq     printmsgdone   ;end of strint yet?
                bsr     putchar        ;if not, print character and do next
                bra     printmsgloop
printmsgdone    pulx 
                pula
                rts
;***********end of printmsg********************

;***************putchar************************
;* Program: Send one character to SCI port, terminal
;* Input:   Accumulator A contains an ASCII character, 8bit
;* Output:  Send one character to SCI port, terminal
;* Registers modified: CCR
;* Algorithm:
;    Wait for transmit buffer become empty
;      Transmit buffer empty is indicated by TDRE bit
;      TDRE = 1 : empty - Transmit Data Register Empty, ready to transmit
;      TDRE = 0 : not empty, transmission in progress
;**********************************************
putchar     brclr SCISR1,#%10000000,putchar   ; wait for transmit buffer empty
            staa  SCIDRL                      ; send a character
            rts
;***************end of putchar*****************


;****************getchar***********************
;* Program: Input one character from SCI port (terminal/keyboard)
;*             if a character is received, other wise return NULL
;* Input:   none    
;* Output:  Accumulator A containing the received ASCII character
;*          if a character is received.
;*          Otherwise Accumulator A will contain a NULL character, $00.
;* Registers modified: CCR
;* Algorithm:
;    Check for receive buffer become full
;      Receive buffer full is indicated by RDRF bit
;      RDRF = 1 : full - Receive Data Register Full, 1 byte received
;      RDRF = 0 : not full, 0 byte received
;**********************************************

getchar     brclr SCISR1,#%00100000,getchar7
            ldaa  SCIDRL
            rts
getchar7    clra
            rts
;****************end of getchar**************** 

;****************nextline**********************
nextline    psha
            ldaa  #CR              ; move the cursor to beginning of the line
            jsr   putchar          ;   Cariage Return/Enter key
            ldaa  #LF              ; move the cursor to next line, Line Feed
            jsr   putchar
            pula
            rts
;****************end of nextline***************


;****************hex2asciiDec******************
;* Program: converts a hex number to ascii-formatted decimal, max. 5 digits
;*             
;* Input:  a hex number in D     
;* Output: that same number in ascii-formatted decimal in DecBuff 
;*          
;*          
;* Registers modified: A, B, X, CCR
;* Algorithm: read the comments
;   
;**********************************************
hex2asciiDec    ;pshx            ; save registers to stack
                ;pshy
                ;pshc
                
                clr   HCount    ;clear HCount so we can reuse it as a loop counter
                cpd   #$0000    ;check if the hex number is already 0 -- $0 is equiv. to decimal 0
                lbeq  CHEESEBURGER


preConvLoop     ldy   #DecBuff
convertLoop     ldx   #10       ; set divisor = 10
                idiv            ; Hex / 10   
                  
                stab  1,Y+      ; store first decimal digit into the decimal buffer
                inc   HCount    ; 1 division completed, 1 remainder obtained
                tfr   X,D       ; copy division result back into D
                tstb            ; check if the result was 0
                bne   convertLoop; if not, branch back to start of loop
                
                
reverse         ldaa  HCount    
                cmpa  #$05      ; check how many remainders were calculated (how long the decimal number is)
                beq   five
                cmpa  #$04
                beq   four
                cmpa  #$03
                lbeq   three
                cmpa  #$02
                lbeq   two
                                ; only 1 remainder, we can convert it here
                ldx   #DecBuff  ; reload the buffer
                ldaa  0,X       ; load 1s place
                adda  #$30      
                staa  1,X+      ; store converted 1s place, X++
                ldaa  #$00      ; load NULL into A
                staa  1,X+      ; store null terminator
                rts


five            ldx   #DecBuff
                ldaa  1,X+      ; load the 1s place remainder into A
                inx
                inx
                inx
                ldab  0,X       ; load the 10000s place remainder into B
                staa  0,X       ; put the 1s place into the 1s place
                ldx   #DecBuff
                stab  0,X       ; put the 10000s place into the 10000s place
                
                inx             ; move to 1000s place
                ldaa  1,X+      ; load current 1000s place (supposed to be 10s) and do X++
                inx             ; skip current 100s place
                ldab  0,X       ; load current 10s place (supposed to be 1000s)
                staa  0,X       ; put current 1000s into 10s place
                ldx   #DecBuff  ; reload buff
                inx             ; move to 1000s place
                stab  0,X       ; put proper 1000s place (former 10s) into 1000s place
                
                ldx   #DecBuff  ; reload buff
                ldaa  0,X       ; load 10000s place into A
                adda  #$30      ;add ASCII offset
                staa  1,X+      ; store converted 10000s place and do X++
                ldaa  0,X       ; load 1000s place into A
                adda  #$30      ;add ASCII offset
                staa  1,X+      ; store converted 1000s place and do X++
                ldaa  0,X       ; load 100s place into A
                adda  #$30      ;add ASCII offset
                staa  1,X+      ; store converted 100s place and do X++
                ldaa  0,X       ; load 10s place into A
                adda  #$30
                staa  1,X+      ; store converted 10s place, X++
                ldaa  0,X       ; load 1s place
                adda  #$30      
                staa  1,X+      ; store converted 1s place, X++
                ldaa  #$00      ; load NULL into A
                staa  1,X+      ; store null terminator
                rts


four            ldx   #DecBuff
                ldaa  1,X+      ; load the 1s place remainder into A
                inx
                inx
                ldab  0,X       ; load the 1000s place remainder into B
                staa  0,X       ; put the 1s place into the 1s place
                ldx   #DecBuff
                stab  0,X       ; put the 1000s place into the 1000s place
                
                inx             ; move to 100s place
                ldaa  1,X+      ; load current 100s place (supposed to be 10s) and do X++
                ldab  0,X       ; load current 10s place (supposed to be 100s)
                staa  0,X       ; put current 100s into 10s place
                ldx   #DecBuff  ; reload buff
                inx             ; move to 100s place
                stab  0,X       ; put proper 100s place (former 10s) into 100s place
                
                ldx   #DecBuff  ; reload buff
                ldaa  0,X       ; load 1000s place into A
                adda  #$30      ;add ASCII offset
                staa  1,X+      ; store converted 1000s place and do X++
                ldaa  0,X       ; load 100s place into A
                adda  #$30      ;add ASCII offset
                staa  1,X+      ; store converted 100s place and do X++
                ldaa  0,X       ; load 10s place into A
                adda  #$30
                staa  1,X+      ; store converted 10s place, X++
                ldaa  0,X       ; load 1s place
                adda  #$30      
                staa  1,X+      ; store converted 1s place, X++
                ldaa  #$00      ; load NULL into A
                staa  1,X+      ; store null terminator
                rts


three           ldx   #DecBuff
                ldaa  1,X+      ; load the 1s place remainder into A
                inx
                ldab  0,X       ; load the 100s place remainder into B
                staa  0,X       ; put the 1s place into the 1s place
                ldx   #DecBuff
                stab  0,X       ; put the 100s place into the 100s place
                
                ldaa  0,X       ; load 100s place into A
                adda  #$30      ;add ASCII offset
                staa  1,X+      ; store converted 100s place and do X++
                ldaa  0,X       ; load 10s place into A
                adda  #$30
                staa  1,X+      ; store converted 10s place, X++
                ldaa  0,X       ; load 1s place
                adda  #$30      
                staa  1,X+      ; store converted 1s place, X++
                ldaa  #$00      ; load NULL into A
                staa  1,X+      ; store null terminator
                rts
                

two             ldx   #DecBuff
                ldaa  1,X+      ; load the 1s place remainder into A
                ldab  0,X       ; load the 10s place remainder into B
                staa  0,X       ; put the 1s place into the 1s place
                ldx   #DecBuff  
                stab  0,X       ; put the 10s place into the 10s place
                
                ldaa  0,X       ; load 10s place into A
                adda  #$30      ;add ASCII offset
                staa  1,X+      ; store converted 10s place and do X++
                ldaa  0,X       ; load 1s place into A
                adda  #$30
                staa  1,X+      ; store converted 1s place, X++
                ldaa  #$00      ; load NULL into A
                staa  1,X+      ; store null terminator
                
                ;pulc
                ;puly
                ;pulx
                
                
                rts

               
CHEESEBURGER    ldx   #DecBuff  ;hex input was just 0. we can skip convoluted conversion and do it manually
                ldaa  #$30      ; $30 == '0'
                staa  1,X+      
                ldaa  #$00      ; null
                staa  1,X+               
                
                ;pulc
                ;puly
                ;pulx
                
                rts

;************end of hex2asciiDec***************


;OPTIONAL
;more variable/data section below
; this is after the program code section
; of the RAM.  RAM ends at $3FFF
; in MC9S12C128 chip

msg1          DC.B    'Hello, this is 1024 ADC conversionprogram.', $00
msg2          DC.B    'When ready, hit Enter key.', $00
msg3          DC.B    '> Be sure to start saving Terminal data: open Output file = RxData3.txt', $00
msg4          DC.B    '> When ready, press the switch SW0 for 1024 point analog data conversion.', $00
msg5          DC.B    '> Done! You may close the Output File.', $00
msg6          DC.B    '> Ready for next data transmission.', $00


